@inreference{abi,
  title = {Application Binary Interface},
  booktitle = {Wikipedia},
  date = {2025-07-13T20:33:55Z},
  url = {https://en.wikipedia.org/w/index.php?title=Application_binary_interface&oldid=1300347152},
  urldate = {2025-08-19},
  abstract = {An application binary interface (ABI) is an interface exposed by software that is defined for in-process machine code access. Often, the exposing software is a library, and the consumer is a program. An ABI is at a relatively low-level of abstraction. Interface compatibility depends on the target hardware and the software build toolchain. In contrast, an application programming interface (API) defines access in source code which is a relatively high-level, hardware-independent, and human-readable format. An API defines interface at the source code level, before compilation, whereas an ABI defines an interface to compiled code. API compatibility is generally the concern for system design and of the toolchain. However, a programmer may have to deal with an ABI directly when writing a program in multiple languages or when using multiple compilers for the same language. A complete ABI enables a program that supports an ABI to run without modification on multiple operating systems that provide the ABI. The target system must provide any required libraries (that implement the ABI), and there may be other prerequisites.},
  langid = {english},
  annotation = {Page Version ID: 1300347152}
}

@software{assemblyscript_git,
  title = {{{AssemblyScript}}/Assemblyscript},
  date = {2025-08-19T11:16:22Z},
  origdate = {2017-09-28T11:06:50Z},
  url = {https://github.com/AssemblyScript/assemblyscript},
  urldate = {2025-08-19},
  abstract = {A TypeScript-like language for WebAssembly.},
  organization = {The AssemblyScript Project},
  keywords = {assemblyscript,compiler,typescript,wasm,webassembly}
}

@online{automotive_ota,
  title = {What Is {{OTA}} in Automotive? {{Over}} the Air Updates Explained.},
  shorttitle = {What Is {{OTA}} in Automotive?},
  author = {Press, Rambus},
  url = {https://www.rambus.com/blogs/ota-updates-explained/},
  urldate = {2025-08-17},
  abstract = {Over-the-air (OTA) programming refers to the ability to download applications, services, and configurations over a mobile or cellular network.},
  langid = {american},
  organization = {Rambus}
}

@online{cabi,
  title = {Component-Model/Design/Mvp/{{CanonicalABI}}.Md at Main · {{WebAssembly}}/Component-Model},
  url = {https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md},
  urldate = {2025-08-19}
}

@online{cranelift,
  title = {Cranelift},
  url = {https://cranelift.dev/},
  urldate = {2025-08-19}
}

@online{criterion_docs,
  title = {Criterion.Rs - {{Criterion}}.Rs {{Documentation}}},
  author = {{bheisler}},
  url = {https://bheisler.github.io/criterion.rs/book/criterion_rs.html},
  urldate = {2025-08-17}
}

@software{emscripten_git,
  title = {Emscripten-Core/Emscripten},
  date = {2025-08-19T16:31:41Z},
  origdate = {2011-02-12T05:23:30Z},
  url = {https://github.com/emscripten-core/emscripten},
  urldate = {2025-08-19},
  abstract = {Emscripten: An LLVM-to-WebAssembly Compiler},
  organization = {emscripten-core},
  keywords = {emscripten,hacktoberfest,wasm,webassembly}
}

@online{eu_cyber_res_act,
  title = {Cyber {{Resilience Act}} | {{Shaping Europe}}’s Digital Future},
  url = {https://digital-strategy.ec.europa.eu/en/policies/cyber-resilience-act},
  urldate = {2025-08-17},
  abstract = {The Cyber Resilience Act enhances cybersecurity standards of products that contain a digital component, requiring manufacturers and retailers to ensure cybersecurity throughout the lifecycle of their products.},
  langid = {english}
}

@software{friedrich_impl,
  title = {Idlab-Discover/I2c-Wasm-Components},
  date = {2025-02-24T22:04:31Z},
  origdate = {2023-12-19T08:25:38Z},
  url = {https://github.com/idlab-discover/i2c-wasm-components},
  urldate = {2025-08-19},
  abstract = {A proof of concept for using WebAssembly together with I2C},
  organization = {IDLab DISCOVER},
  keywords = {embedded,i2c,wasi,wasmtime,wit}
}

@article{friedrich_paper,
  title = {Advancing the {{I2C}} Proposal for {{WebAssembly System Interface}} /},
  author = {Vandenberghe, Friedrich},
  date = {2024},
  url = {https://lib.ugent.be/catalog/rug01:003214608}
}

@inreference{hal,
  title = {Hardware Abstraction},
  booktitle = {Wikipedia},
  date = {2025-08-12T14:02:11Z},
  url = {https://en.wikipedia.org/w/index.php?title=Hardware_abstraction&oldid=1305514254},
  urldate = {2025-08-19},
  abstract = {Hardware abstractions are sets of routines in software that provide programs with access to hardware resources through programming interfaces. The programming interface allows all devices in a particular class C of hardware devices to be accessed through identical interfaces even though C may contain different subclasses of devices that each provide a different hardware interface. Hardware abstractions often allow programmers to write device-independent, high performance applications by providing standard operating system (OS) calls to hardware. The process of abstracting pieces of hardware is often done from the perspective of a CPU. Each type of CPU has a specific instruction set architecture or ISA. The ISA represents the primitive operations of the machine that are available for use by assembly programmers and compiler writers. One of the main functions of a compiler is to allow a programmer to write an algorithm in a high-level language without having to care about CPU-specific instructions. Then it is the job of the compiler to generate a CPU-specific executable. The same type of abstraction is made in operating systems, but OS APIs now represent the primitive operations of the machine, rather than an ISA. This allows a programmer to use OS-level operations (e.g. task creation/deletion) in their programs while retaining portability over a variety of different platforms.},
  langid = {english},
  annotation = {Page Version ID: 1305514254}
}

@article{i2c_specification,
  title = {{{I2C-bus}} Specification and User Manual},
  date = {2021},
  volume = {2021},
  abstract = {Philips Semiconductors (now NXP Semiconductors) developed a simple bidirectional 2-wire bus for efficient inter-IC control, called the Inter-IC or I2Cbus. Only two bus lines are required: a serial data line (SDA) and a serial clock line (SCL). Serial, 8-bit oriented, bidirectional data transfers can be made at up to 100 kbit/s in Standard-mode, up to 400 kbit/s in Fast-mode, up to 1 Mbit/s in Fast-mode Plus (Fm+), or up to 3.4 Mbit/s in High-speed mode. Ultra Fast-mode is a unidirectional mode with data transfers of up to 5 Mbit/s.},
  langid = {english},
  file = {C:\Users\robin\Zotero\storage\PIDC8EFR\2021 - I2C-bus specification and user manual.pdf}
}

@artwork{img_arduino_icon,
  title = {English:  {{Arduino Uno Microcontroller Board}}},
  shorttitle = {English},
  author = {{PhilippHenkel}},
  date = {2018-11-09},
  url = {https://commons.wikimedia.org/wiki/File:ArduinoUno.svg},
  urldate = {2025-08-09}
}

@online{img_rpi_icon,
  title = {Raspberry {{Pi Icon}} \#35510 - {{Free Icons Library}}},
  url = {https://icon-library.com/icon/raspberry-pi-icon-20.html},
  urldate = {2025-08-09}
}

@online{jco_docs,
  title = {Introduction - Jco},
  url = {https://bytecodealliance.github.io/jco/},
  urldate = {2025-08-19}
}

@article{rossberg2018webassembly,
  title = {Bringing the {{Web}} up to {{Speed}} with {{WebAssembly}}},
  author = {Rossberg, Andreas and Titzer, Ben L and Haas, Andreas},
  abstract = {The maturation of the Web platform has given rise to sophisticated Web applications such as 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. WebAssembly is a portable low-level bytecode that addresses these requirements by offering a compact representation, efficient validation and compilation, and safe execution with low to no overhead. It has recently been made available in all major browsers. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it independent of language, hardware, and platform and applicable far beyond just the Web. WebAssembly is the first mainstream language that has been designed with a formal semantics from the start, finally utilizing formal methods that have matured in programming language research over the last four decades.},
  langid = {english},
  file = {C:\Users\robin\Zotero\storage\Y9FYG3FW\Rossberg e.a. - Bringing the Web up to Speed with WebAssembly.pdf}
}

@online{rust_wasm_target,
  title = {Platform {{Support}} - {{The}} Rustc Book},
  url = {https://doc.rust-lang.org/rustc/platform-support.html#tier-2-with-host-tools},
  urldate = {2025-08-19}
}

@online{wabt_git,
  title = {{{WebAssembly}}/Wabt: {{The WebAssembly Binary Toolkit}}},
  url = {https://github.com/WebAssembly/wabt/tree/main},
  urldate = {2025-08-19}
}

@online{wamr_project,
  title = {{{WebAssembly Micro Runtime}}},
  url = {https://bytecodealliance.github.io/wamr.dev/},
  urldate = {2025-08-19},
  abstract = {WebAssembly Micro Runtime (WAMR) is a lightweight standalone WebAssembly (WASM) runtime with small footprint, high performance and highly configurable features for applications cross from embedded, IoT, edge to Trusted Execution Environment (TEE), smart contract, cloud native and so on.},
  langid = {american},
  organization = {WAMR}
}

@software{wamr_project2,
  title = {Bytecodealliance/Wasm-Micro-Runtime},
  date = {2025-08-19T00:53:55Z},
  origdate = {2019-05-02T21:32:09Z},
  url = {https://github.com/bytecodealliance/wasm-micro-runtime},
  urldate = {2025-08-19},
  abstract = {WebAssembly Micro Runtime (WAMR)},
  organization = {Bytecode Alliance},
  keywords = {aot,assembly-script,embedded,interpreter,iot,jit,pthread,runtime,sgx,wasi-nn,wasi-threads,wasm,wasm-socket,webassembly}
}

@online{wasi_component_model,
  title = {Introduction - {{The WebAssembly Component Model}}},
  url = {https://component-model.bytecodealliance.org/},
  urldate = {2025-08-18}
}

@software{wasi_i2c_proposal,
  title = {{{WebAssembly}}/Wasi-I2c},
  date = {2025-05-29T17:20:03Z},
  origdate = {2023-03-31T22:38:38Z},
  url = {https://github.com/WebAssembly/wasi-i2c},
  urldate = {2025-08-19},
  abstract = {I2C API for WASI},
  organization = {WebAssembly},
  keywords = {proposal,wasi}
}

@online{wasip_p2,
  title = {{{WASI}} 0.2 {{Launched}}},
  author = {Gohman, Dan},
  date = {2024-01-25T00:00:00+00:00},
  url = {https://bytecodealliance.org/articles/WASI-0.2},
  urldate = {2025-08-17},
  abstract = {The WASI Subgroup voted on January 25, 2024 to launch WASI 0.2, also knownas WASI Preview 2, or WASIp2!  This blog post is a brief look at the present,past, and future of WASI, and a repost of an original article sharedhere.},
  langid = {english},
  organization = {Bytecode Alliance}
}

@software{wasisdk,
  title = {{{WebAssembly}}/Wasi-Sdk},
  date = {2025-08-17T12:06:08Z},
  origdate = {2019-03-06T19:07:27Z},
  url = {https://github.com/WebAssembly/wasi-sdk},
  urldate = {2025-08-18},
  abstract = {WASI-enabled WebAssembly C/C++ toolchain},
  organization = {WebAssembly},
  keywords = {llvm,sysroot,wasi-libc,wasi-sdk}
}

@online{wasm_spec,
  title = {Feature {{Status}} - {{WebAssembly}}},
  url = {https://webassembly.org/features/},
  urldate = {2025-08-17},
  abstract = {WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.},
  langid = {english}
}

@online{wasm_tools_git,
  title = {Bytecodealliance/Wasm-Tools: {{CLI}} and {{Rust}} Libraries for Low-Level Manipulation of {{WebAssembly}} Modules},
  url = {https://github.com/bytecodealliance/wasm-tools/tree/main},
  urldate = {2025-08-19}
}

@online{wasmtime_bindgen_docs,
  title = {Bindgen in Wasmtime::Component - {{Rust}}},
  url = {https://docs.wasmtime.dev/api/wasmtime/component/macro.bindgen.html},
  urldate = {2025-08-19}
}

@online{wasmtime_project,
  title = {Introduction - {{Wasmtime}}},
  url = {https://docs.wasmtime.dev/},
  urldate = {2025-08-19}
}

@software{wit_bindgen_git,
  title = {Bytecodealliance/Wit-Bindgen},
  date = {2025-08-19T17:21:55Z},
  origdate = {2021-02-23T22:25:51Z},
  url = {https://github.com/bytecodealliance/wit-bindgen},
  urldate = {2025-08-19},
  abstract = {A language binding generator for WebAssembly interface types},
  organization = {Bytecode Alliance},
  keywords = {interface-types,module-linking,rust,wasi,wasmtime,webassembly}
}

@online{wit_specification,
  title = {{{WIT Reference}} - {{The WebAssembly Component Model}}},
  url = {https://component-model.bytecodealliance.org/design/wit.html},
  urldate = {2025-08-19}
}

@online{witx_docs,
  title = {{{WASI}}/Legacy/Tools/Witx-Docs.Md at Main · {{WebAssembly}}/{{WASI}}},
  url = {https://github.com/WebAssembly/WASI/blob/main/legacy/tools/witx-docs.md},
  urldate = {2025-08-19},
  abstract = {WebAssembly System Interface. Contribute to WebAssembly/WASI development by creating an account on GitHub.},
  langid = {english},
  organization = {GitHub}
}
