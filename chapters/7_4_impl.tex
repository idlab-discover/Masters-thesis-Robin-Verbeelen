\chapter{Implementation}
\label{chap:4}


design
Intro over de verschillende implementaties

uitleg om aan de portability te voldoen er implementaties moeten bestaan voor very constrained devices. Deze hebben de resources niet voor een Wasmtime implementatie en dus moet wamr synchroon gemaakt worden.
=> Start van ontwikkeling voor een preview 1 implementatie van de interface

wit setup

Wasi p1 bindings (lib)

Guests
- p1 (focus): bespreek wamr-heap (host vs guest managed)
- p2

hosts
- wamr (focus)
- wasmtime









impl

Dev env: rust, cross comp en justfile

p1 bindings
- waarom geen wit-bindgen
- code highlights
- type mapping from wit to p1
- Error handling (lack of system of reporting wamr problems vs i2c errors)

Wamr
- host function registration
    - exec\_env available in host param
    - converting pointers from guest to native
- ACL on handles (I2cPermManager)
- registering managed host heap size when using host-managed heap

Wasmtime
- Focus on differences instead of actual implementation
- bespreek meest belangrijke code met codeblocks

Usage of Linux embedded HAL voor host functions in beide runtimes
Mapping van errors makkelijk sinds i2c interface based on embedded-hal

Benchmarking framework design en mogelijkheden, maar uitgebreidere implementatiebespreking is pas voor chap:evaluation