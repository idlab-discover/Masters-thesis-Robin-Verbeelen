\chapter*{Conclusion}
\chaptermark{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\refstepcounter{chapter}
\label{chap:conclusion}

This thesis addressed the critical challenge of bridging WASI Preview 2 \acrshort{i2c} interface specifications with resource-constrained embedded systems through a comprehensive implementation of a Preview 1 kit. By developing manual bindings, runtime integrations, and comparative frameworks, this work advances the WASI \acrshort{i2c} standardization effort while providing empirical insights into WebAssembly runtime performance trade-offs in embedded environments.

\section*{Research Questions Answered}
\label{sec:research-questions-answered}

\textbf{Research Question 1: How can the WASI Preview 2 \acrshort{i2c} interface be effectively adapted for WASI Preview 1 environments while maintaining functional compatibility with the standardized Preview 2 specification?}

Chapter \ref{chap:implementation} demonstrated successful adaptation of Preview 2 interface semantics to Preview 1 environments through manual binding implementation. The \texttt{wasip1-i2c-lib}~\cite{p1_lib} library successfully translates resource-based \acrshort{i2c} controller management, error handling, and simple communication patterns to Preview 1's function call mechanisms while maintaining type safety and functional equivalence with Preview 2 implementations. This validates that the interface can target both modern component model environments and resource-constrained systems.

\textbf{Research Question 2: How do Preview 1 and Preview 2 approaches compare in terms of developer experience, maintainability, and implementation complexity?}

The analysis reveals fundamental trade-offs between developer convenience and deployment flexibility. Preview 2's automatic code generation provides superior developer experience through \texttt{wit-bindgen}, while Preview 1 approaches offer advantages in embedded contexts: implementation transparency, runtime simplicity, deployment flexibility with lightweight runtimes like WAMR, and optimization opportunities. The development effort for manual Preview 1 bindings represents a significant investment compared to automatic generation, but enables deployment in resource-constrained environments where Preview 2 approaches are infeasible. A binding generator that provides support for Preview 1 modules could lower the Preview 1 developer overhead. This is discussed in section \hyperref[sec:fw-p1-bindgen]{Preview 1 Bindings Generation} of the \hyperref[chap:future-work]{future work chapter}.

\textbf{Research Question 3: What are the performance implications of WASI Preview 2 compared to Preview 1 for embedded \acrshort{i2c} applications?}

The empirical evaluation reveals dramatic performance differences with clear embedded deployment implications. WAMR demonstrates 77x faster startup (253μs vs 19,559μs) and dramatically lower Flash memory requirements (10KB vs 2.7MB peak usage). Wasmtime's memory usage, of this work's implementation, would exceed the RAM limitations of ESP32-C3 and Nucleo F412ZG platforms, and therefore already would not meet the Portability Criteria. Both runtimes achieve efficient steady-state execution of their guest module/component, a 2x latency compared to native, and remain acceptable memory consumption (WAMR: 327 bytes, Wasmtime: 416 bytes). \textbf{These findings establish WAMR as viable for resource-constrained applications while Wasmtime only remains viable for more capable (embedded) platforms}. Notice, the results demonstrate that WAMR is already able to meet the requirements defined by the Portability Criteria. Optimization opportunities, that extend beyond this first experimental implementation, are discussed in the \hyperref[chap:future-work]{future work chapter}.

\section*{Impact on WASI I2C Standardization}
\label{sec:standardization-impact}

This work provides advances of the WASI \acrshort{i2c} proposal~\cite{wasi_i2c_proposal} --- toward Phase 3 requirements --- by addressing critical embedded system compatibility.

The advancements of the proposal to its current state revealed dependency on WASI Preview 2 and component model architecture that created embedded deployment barriers. \textbf{The developed Preview 1 compatibility} from this research eliminates these barriers by demonstrating that the WASI \acrshort{i2c} interface \textbf{accommodates resource-constrained environments without compromising functionality}. The successful WAMR integration proves lightweight WebAssembly runtimes can provide \acrshort{i2c} hardware access while maintaining interface semantic integrity.

\textbf{Key standardization contributions} include embedded compatibility demonstration, performance baselines for deployment decisions, and a complete Preview 1 reference implementation~\cite{wamr-wasi-i2c}. Beyond \acrshort{i2c}-specific contributions, this work establishes approaches for adapting WASI Preview 2 interfaces defined in WIT-files to embedded environments, providing methodology templates for other hardware interfaces (e.g., SPI, PWM, UART).

\section*{Threats to Validity}
\label{sec:limitations}

This investigation acknowledges several limitations that constrain the generalizability and scope of findings:

\textbf{Workload Scope:} The evaluation focuses exclusively on the simple ping-pong \acrshort{i2c} operations, which may not represent the complexity of production embedded applications with sophisticated transaction sequences, concurrent device communication, and error recovery scenarios.

\textbf{Hardware Specificity:} Results are specific to the Raspberry Pi and Arduino experimental setup. Performance characteristics may vary significantly across different embedded platforms, \acrshort{i2c} implementations, and hardware configurations.

\textbf{Scale Considerations:} The single-operation focus may not accurately represent scenarios involving bulk \acrshort{i2c} transactions, concurrent device management, or sustained high-frequency communication patterns typical in industrial embedded applications.

\textbf{Interface Coverage:} The implementation utilizes a simplified version of the WASI \acrshort{i2c} interface rather than the complete official specification. While enabling focused evaluation of core functionality, this may not capture performance implications of full interface complexity.

\textbf{Optimization Potential:} The evaluation does not explore advanced optimization strategies that could potentially improve Wasmtime's embedded compatibility, such as ahead-of-time compilation, custom component model configurations, or memory optimization techniques.

\textbf{Runtime-Preview Coupling:} The comparison conflates Preview version differences with runtime implementation differences. While the intention is to compare Preview 1 versus Preview 2 approaches, the evaluation necessarily uses different runtimes (WAMR for Preview 1, Wasmtime for Preview 2), making it impossible to isolate whether observed performance differences stem from Preview version characteristics or runtime-specific implementation choices and optimizations.

\textbf{Non-Standard ABI Implementation:} For experimental purposes, the Preview 1 \acrshort{i2c} interface implementation deliberately deviates from the Canonical ABI, which defines standardized data transfer mechanisms between host and guest environments and between WebAssembly modules. While this simplification facilitates focused evaluation of core \acrshort{i2c} functionality, it compromises interoperability with other WebAssembly components that expect standard ABI compliance, limiting the implementation's integration potential in production WebAssembly ecosystems.