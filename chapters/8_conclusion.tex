\chapter*{Conclusion}
\chaptermark{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}  






Experienced problems: (outdated wamr documentation, weird specifieke git versions en tags van libraries moeten gebruiken, ...)

When WAMR, when Wasmtime
embedded systems
Performance vs features

Impact op het I2C proposal

bepalen of we dit hier willen steken of zoals het template zegt om dit na de conclusion te steken
Future work
wasi p3? -> async enz
uitbreiding van interface standaard (aanvragen van i2c resource, met core interface als dependency)
no std builds
host managed heap opties:
 - vergelijking maken bij normal use cases van i2c en niet gewoon een simpele pingpong dat succes garandeerd.
 - wat er zal gebeuren qua memory usage wanneer grotere berichten falen of lukken, ...
focus op security implicaties?


















% \section{Discussion and Implications}
% \label{sec:eval-discussion}

% % TODO: Decide - versie hieronder met meer uitleg en beschrijving of huidige versie dat meer concise is
% % \subsection{Key Findings Summary}
% % \label{subsec:eval-discussion-keyfindings}

% % The experimental evaluation reveals several critical insights that directly address the research question on WebAssembly runtime performance impact:
% % \begin{enumerate}
% %     \item \textbf{Dramatic Setup Performance Divergence:} The most striking finding is the extreme disparity in runtime initialization overhead. WAMR demonstrates a 77x faster setup time (253μs vs 19.6ms) compared to Wasmtime, while both exhibit substantial overhead relative to native implementation (130x and 10,048x respectively). This three-order-of-magnitude difference between WebAssembly runtimes fundamentally impacts their applicability in embedded scenarios requiring frequent instantiation.
% %     \item \textbf{Convergent Steady-State Performance:} Despite their architectural differences, both WAMR and Wasmtime achieve remarkably similar execution performance, with both implementations exhibiting consistent 2x overhead compared to native execution (WAMR: 1,185μs vs Wasmtime: 1,184μs for hot execution). This convergence demonstrates that WASI Preview 1 versus Preview 2 differences have minimal impact on steady-state I2C operation performance, with the overhead primarily attributable to WebAssembly instruction execution and host function marshalling costs.
% %     \item \textbf{Memory Usage Scaling Patterns:} Memory consumption analysis reveals a clear scaling hierarchy: while WAMR requires moderate setup memory (10KB), Wasmtime demands substantial resources (14.2MB total, 2.7MB peak). However, both runtimes demonstrate excellent execution memory efficiency, requiring only hundreds of bytes for actual I2C operations (WAMR: 327B, Wasmtime: 416B). This pattern indicates that memory overhead concentrates in initialization rather than steady-state execution.
% %     \item \textbf{Performance Consistency Characteristics:} Variability analysis demonstrates that all implementations achieve excellent measurement consistency (CV < 1\%), with native implementation showing superior hot execution consistency (0.012\% CV) compared to WebAssembly runtimes (WAMR: 0.057\%, Wasmtime: 0.044\%). Interestingly, Wasmtime exhibits the most consistent setup behavior (0.06\% CV), suggesting that its complex initialization process, while slow, follows deterministic patterns.
% %     \item \textbf{Architectural Impact Quantification:} The experimental results provide concrete quantification of Component Model overhead: Wasmtime's sophisticated component instantiation, WIT interface resolution, and type checking processes contribute directly to the 77x setup time penalty and 1,400x memory overhead compared to WAMR's simpler module-based approach. However, this architectural complexity yields no measurable steady-state performance advantage for simple I2C operations.
% % \end{enumerate}

% % These findings establish that runtime architecture choice represents a fundamental trade-off between initialization overhead and development experience, with performance characteristics varying by several orders of magnitude depending on the deployment pattern and application requirements.

% %TODO: misschien eerder iets voor Discussion chapter
% \subsection{Practical Decision Framework}
% \label{subsec:decision-framework}

% The experimental results establish clear selection criteria for different deployment scenarios:

% \textbf{Choose WAMR when:}
% \begin{itemize}
%     \item Frequent runtime instantiation required (IoT, embedded systems)
%     \item Memory constraints are critical 
%     \item Startup latency must remain as low as possible
% \end{itemize}

% \textbf{Choose Wasmtime when:}
% \begin{itemize}
%     \item Long-running applications can amortize setup costs
%     \item Maximum standards compliance and ecosystem compatibility required
%     \item Development velocity and tooling quality prioritized
%     \item Applications can tolerate initialization overhead
% \end{itemize}

% \textbf{Choose Native when:}
% \begin{itemize}
%     \item Maximum performance required
%     \item Platform lock-in acceptable for specific hardware optimization
%     \item WebAssembly features not required for the application domain (sandboxing, host/guest isolation, ...)
% \end{itemize}

% \subsection{Limitations and Validity Considerations}
% \label{subsec:limitations}

% Several limitations must be considered when interpreting these results:

% \textbf{Experimental Scope Limitations:}
% \begin{itemize}
%     \item \textbf{Workload Simplicity:} Single ping-pong operations may not represent complex I2C transaction patterns
%     \item No stress testing, monitoring error behavior
%     \item \textbf{Hardware Specificity:} Results specific to Raspberry Pi + Arduino configuration
%     \item \textbf{Scale Limitations:} Single-operation focus may not capture bulk transfer scenarios
%     \item \textbf{Environmental Control:} Laboratory conditions may not reflect real deployment environments
% \end{itemize}

% \textbf{Generalizability Constraints:}
% \begin{itemize}
%     \item \textbf{Architecture Dependence:} ARM64-specific results may not generalize to x86 or other architectures
%     \item \textbf{Version Sensitivity:} Results tied to specific runtime versions and may change with updates
% \end{itemize}

% \section{Conclusion}
% \label{sec:eval-conclusion}

% This chapter presented a comprehensive performance evaluation of WebAssembly runtimes implementing the proposed WASI I2C standard. Through systematic measurement of initialization overhead, execution latency, and memory consumption, we quantified the practical trade-offs between WAMR's embedded-optimized architecture and Wasmtime's standards-compliant component model.

% The evaluation definitively answers RQ2: \textit{WebAssembly runtime architecture creates dramatic performance variations during initialization (77x difference) but negligible impact on steady-state execution (both ~2x native overhead).} This finding challenges the assumption that runtime sophistication translates to execution performance, revealing instead that architectural complexity primarily impacts initialization.

% These results validate WebAssembly's viability for embedded systems while highlighting the critical importance of runtime selection. For the embedded I2C domain, WAMR's pragmatic design proves more suitable than Wasmtime's feature-rich architecture.

% \section*{Reproducibility}
% All experimental code, benchmarks, and analysis scripts are available at: \url{https://github.com/idlab-discover/wamr-wasi-i2c}. The repository includes automated setup scripts enabling complete reproduction of these results.

RQ answered?
Hoofdzaken eruit halen, kleine summary