\chapter*{Future Work}
\chaptermark{Future Work}
\addcontentsline{toc}{chapter}{Future Work}
\refstepcounter{chapter}
\label{chap:future-work}

This thesis establishes Preview 1 \acrshort{i2c} interface compatibility and provides performance benchmarks for WAMR and Wasmtime implementations. Several research directions emerge from this foundation.

\section*{Standardization and Testing}
\label{sec:standardization-testing}

\textbf{Phase 3 standardization} requires comprehensive test suites and examples beyond the current simplified interface implementation. Developing tests for the complete WASI \acrshort{i2c} specification, including error handling scenarios and realistic \acrshort{i2c} peripheral examples, would support the proposal's advancement.

Testing in \textbf{more realistic environments} would reveal practical deployment characteristics. This includes evaluating larger message sizes, examining error conditions and recovery mechanisms, and validating how different types of \acrshort{i2c} transactions perform under WebAssembly constraints.

\section*{Preview 1 Bindings Generation}
\label{sec:fw-p1-bindgen}

Developing a binding generator capable of producing Preview 1 compatible bindings from WIT files could provide significant value to the embedded WebAssembly ecosystem. The uncertainty surrounding whether resource-efficient WebAssembly runtimes will eventually provide component model support raises concerns about the long-term viability of using WASI standardized interfaces in resource-constrained environments.

A Preview 1 compatible binding generator would enable resource-efficient runtimes focused on Preview 1 WASI support (such as WAMR) to directly utilize WIT-defined WASI interfaces without requiring manual binding implementation. This approach would substantially reduce developer overhead when interface specifications evolve, eliminating the need to manually adapt Preview 1 bindings each time the underlying interfaces change.

Such a tool would bridge the gap between the sophisticated interface definition capabilities of the component model and the practical deployment requirements of embedded systems. It would allow the embedded community to benefit from standardized WASI interface development while maintaining compatibility with lightweight runtimes optimized for resource-constrained environments. This could accelerate adoption of emerging WASI interfaces in embedded applications and ensure that the embedded ecosystem remains aligned with broader WebAssembly standardization efforts.

\section*{Preview 3 Integration}
\label{sec:preview3-integration}

\textbf{WASI 0.3} development, expected by November 2025, introduces native \textbf{async support} through stream<T> and future<T> types. Investigating how far async development has progressed and preparing the \acrshort{i2c} interface for these capabilities could benefit embedded applications requiring asynchronous \acrshort{i2c} operations.

\section*{Runtime Optimization}
\label{sec:runtime-optimization}

Both WAMR and Wasmtime present optimization opportunities. For WAMR, strategies could focus on further reducing startup latency and memory footprint for embedded deployment. For Wasmtime, investigating whether targeted optimizations could make it viable for embedded scenarios remains an open question.

The impact of \textbf{host-managed versus guest-managed heap} implementations represents an unexplored area that could affect embedded deployment characteristics.

\section*{Interface Development}
\label{sec:interface-development}

The current implementation's relationship to \textbf{Canonical ABI compliance} warrants investigation. Determining whether Canonical ABI compatibility can be achieved while maintaining embedded optimizations would improve interoperability when other components/modules interact with the interface.

Re-evaluating the current definition of the \acrshort{i2c} interface could bring additional functionality or reduce developer overhead. For example, \textbf{expanding the interface} to include \textbf{\acrshort{i2c} resource acquisition} would remove the need for manually defining a function in WIT-files for acquiring an \acrshort{i2c} resource. This could enhance capability-based security implementation by providing the developer with best-practice suggestions through optional parameters and provide fine-grained access control.

\section*{Performance and Compatibility Analysis}
\label{sec:performance-compatibility}

\textbf{Distinguishing pure Preview 1 versus Preview 2 performance characteristics}, independent of runtime choice, would clarify whether observed differences stem from WASI version capabilities or runtime implementation strategies. WAMR only supports Preview 1 features and Wasmtime's internal architecture uses Preview 2 techniques even when loading Preview 1 modules~\cite{wasmtime_and_cranelift_2023}~\cite{wasmtime_p1_crate_docs}~\cite{wasmtime_p2_crate_docs}, making this distinction valuable but also difficult to achieve.

\textbf{Comparative benchmarking across different WASI interfaces} would establish whether \acrshort{i2c} performance patterns generalize to other hardware interfaces or represent interface-specific characteristics.

\section*{Security and Hardware Validation}
\label{sec:security-hardware}

\textbf{Security implementation} and analysis represent an underdeveloped aspect of embedded WebAssembly deployment. Examining capability-based security models for hardware interfaces could establish deployment best practices. This could be even more important with the upcoming async-ready Preview 3.

\textbf{Hardware-level validation} using oscilloscopes to measure electrical signals and verify \acrshort{i2c} protocol compliance would confirm that WebAssembly implementations produce correct hardware behavior. This could determine whether peripheral connectivity issues stem from software implementation problems or hardware limitations. In addition, performance of the \acrshort{i2c} Target could be measured and subtracted from the total latency. This would give more insight into the overhead only caused by the \acrshort{i2c} controller, thus achieving even more accurate WebAssembly overhead measurements.

\section*{Other WebAssembly Runtimes}

Research can be extended to other WebAssembly Runtimes, like Wasmer~\cite{wasmer_git}. What do they do differently? What is their take on WASI? What problems do they address? How does their performance relate to other runtimes when using the WASI \acrshort{i2c} interface?




































% - strategies voor het optimaliseren van wasmtime, wamr, ... \\
% - Kijken of met optimalisaties Wasmtime mss toch viable kan zijn voor embedded? \\
% - Effectief implementeren van duidelijke tests en voorbeelden voor het voorstel naar phase 3 te pushen \\
% - Impact van host-managed vs guest-managed heap \\
% - Testen wat er gebeurd in een correcter environment en niet de simpele PingPong \\
%     - Grotere berichten \\
%     - Foute en juiste berichten \\
%     - Hoe errors worden behandeld \\
% - benchmarks die verschillende dingen vergelijken met andere wasi interfaces die al verder ontwikkeld zijn \\
% - puur het verschil van P1 en P2 gaan bepalen ipv Wasmtime vs WAMR CATCH: Wasmtime gebruikt wss sowieso P2 technieken, ook al laadt je een P1 module in. \\
% - Kijken hoe ver async development staat met Preview 3 en de interface daar voor klaarmaken \\
% - Onderzoeken of de definitie van de interface kan worden uitgebreid: bvb een imported functie definiÃ«ren dat een i2c resource als resultaat geeft. \\
% - Ervoor zorgen dat de P1 interface een versie heeft dat compatibel is met Canonical ABI compatible. Het gebruiken van een standaard brengt veel positieve gevolgen mee. \\






% - Eens kijken of er meer aandacht kan worden besteed aan het implementeren en analyseren van security \\
% - Testen uitvoeren op hardware niveau? Elektriciteitsignalen meten op de pinnen, manueel software testen schrijven. Dit kan nagaan of de I2C peripheral weldegelijk direct een request kan versturen, misschien ondervond de arduino uno even wat problemen tijdens metingen en zorgt dit voor instabiele metingen? Men kan zo de tijd dat de peripheral nodig heeft voor requests te verwerken aftrekken van de total meettijd om specifiekere resultaten van de controller te bekomen.