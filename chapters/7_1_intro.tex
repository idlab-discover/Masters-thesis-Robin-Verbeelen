\chapter{Introduction}
\label{chap:introduction}

Modern embedded systems face unprecedented challenges in balancing security, reliability, and updateability requirements while operating under strict resource constraints. The European Union's Cyber Resilience Act, enacted in March 2024, mandates that manufacturers ensure effective vulnerability management and provide security updates throughout a product's expected lifespan~\cite{eu_cyber_res_act}. Simultaneously, the automotive industry's rapid adoption of over-the-air (OTA) software distribution demands robust rollback capabilities when updates fail~\cite{automotive_ota}. These regulatory and industry pressures converge on a fundamental need: secure, reliable, and easily updatable software solutions that impose minimal overhead on resource-constrained Internet of Things (IoT) devices.

WebAssembly (Wasm) and its system interface specification, WASI (WebAssembly System Interface), represent a promising technological response to these challenges. Originally designed to execute binary code within web browsers, WebAssembly has evolved beyond its initial scope to enable portable, secure, and efficient code execution across diverse environments~\cite{wasm_spec}. WASI extends this capability by providing a standardized system interface that facilitates interaction with filesystems, network resources, and hardware peripherals while maintaining WebAssembly's core security guarantees through capability-based access control.

The emergence of WASI Preview 2, accompanied by the component model architecture, introduced sophisticated mechanisms for building interoperable WebAssembly libraries, applications, and environments. This component model utilizes \acrfull{wit} files to define interface contracts and enable automatic binding generation between components~\cite{wasi_p2}. However, a critical gap remains in WASI's hardware interface coverage: despite the ubiquity of Inter-Integrated Circuit (I2C) communication in embedded systems, the standardization of the WASI I2C interface is only in very early stages.

I2C represents one of the most widely deployed communication protocols in embedded systems, serving as the backbone for sensor communication, device configuration, and inter-chip data exchange in IoT applications~\cite{i2c_specification}. The protocol's simplicity, addressing efficiency, and multi-host capability have made it indispensable for embedded system designers. Yet, the early state of the WASI I2C interface creates a significant barrier to WebAssembly adoption in embedded environments where I2C communication is fundamental.






\section{Problem Statement and Research Context}
\label{sec:problem-statement}

Friedrich Vandenberghe's pioneering work established the foundation for WASI I2C standardization by advancing the proposal from its initial conceptual phase to Phase 2 of the official WASI standardization process~\cite{friedrich_thesis}. His investigation included WIT interface design and proof-of-concept implementations mainly targeting WASI Preview 2 environments. Friedrich's work demonstrated the technical feasibility of WASI I2C integration and provided performance characterizations for Wasmtime-based implementations.

However, Friedrich's implementation approach, while technically sound and aligned with the future direction of WebAssembly component model adoption, revealed a critical limitation for immediate embedded system deployment: dependency on WASI Preview 2 and the component model architecture. These technological requirements impose constraints that conflict with the resource limitations prevalent in embedded environments:

\begin{enumerate}
    \item \textbf{Runtime Complexity}: WASI Preview 2 implementations require sophisticated runtime environments with component model support, limiting compatibility with lightweight WebAssembly runtimes optimized for embedded deployment.
    
    \item \textbf{Binary Size Overhead}: More sophisticated runtimes combined with component model metadata and automatic binding generation introduce significant binary size increases, challenging deployment in memory-constrained embedded systems.
\end{enumerate}

These limitations represent a fundamental tension between the sophisticated developer experience provided by WASI Preview 2 and the resource constraints that define embedded system deployment scenarios. To advance the WASI I2C proposal towards Phase 3 standardization, a Preview 1-compatible implementation becomes essential. This allows for demonstrating compatibility with embedded device constraints.




\section{Research Questions}
\label{sec:research-questions}

This thesis addresses the following research questions, which collectively evaluate the feasibility of the WASI I2C proposal in resource-constrained embedded systems:

\begin{researchquestion}\label{rq1}
\textbf{How can the WASI Preview 2 I2C interface be effectively adapted for WASI Preview 1 environments while maintaining functional compatibility with the standardized Preview 2 specification?}
\end{researchquestion}

This question examines the technical challenges of manually implementing Preview 1 bindings that preserve the semantic richness of WIT-defined interfaces. It investigates type system adaptation strategies, error handling mechanism design, and resource management approaches that enable Preview 1 implementations to provide equivalent functionality to their Preview 2 counterparts.

\begin{researchquestion}\label{rq2}
\textbf{How do Preview 1 and Preview 2 approaches compare in terms of developer experience, maintainability, and implementation complexity?}
\end{researchquestion}

This question evaluates the development and maintenance trade-offs between manual binding implementation and automatic code generation.

\begin{researchquestion}\label{rq3}
\textbf{What are the performance implications of WASI Preview 2 compared to Preview 1 for embedded I2C applications?}
\end{researchquestion}

This question is about a quantitative comparison between WAMR (Preview 1) and Wasmtime (Preview 2) approaches across multiple performance dimensions. It examines startup latency, steady-state execution overhead, memory consumption patterns, and resource utilization efficiency to establish empirical foundations in Preview characteristics.




\section{Contributions and Thesis Structure}
\label{sec:contributions-structure}

This thesis makes several key contributions to the WASI I2C standardization effort and embedded WebAssembly deployment by developing a comprehensive Preview 1 implementation ecosystem that bridges the gap between resource-constrained embedded systems and modern WebAssembly standards.

\subsection{Research Contributions}
\label{subsec:research-contributions}

The primary contributions of this work include:

\begin{enumerate}
    \item \textbf{WASI Preview 1 I2C Bindings Library}: Development of a manual Rust bindings library that faithfully translates WIT-defined I2C interface semantics to Preview 1's function call mechanisms. This library preserves type safety, error handling capabilities, and maintains semantic compatibility with the official WASI I2C specification while operating within Preview 1 constraints.

    \item \textbf{Preview 1 Guest Implementation}: Creation of a WebAssembly Module targeting \sloppy\texttt{wasm32-wasip1} that demonstrates the usage of the Preview 1 bindings and functionality. The implementation emphasizes maintaining full functional compatibility with the Preview 2 Component version.
    
    \item \textbf{WAMR Integration}: Implementation of a complete host runtime based on WebAssembly Micro Runtime (WAMR) that provides I2C hardware access through careful integration between Rust's memory safety model and WAMR's C-based architecture. This contribution demonstrates practical embedded deployment strategies for WASI I2C applications.
    
    \item \textbf{Comparative Preview 2 Framework}: Development of a parallel WebAssembly Component and Wasmtime runtime implementation, enabling comprehensive comparison across different WebAssembly approaches for I2C communication.
    
    \item \textbf{Performance Evaluation Methodology}: Design and implementation of a rigorous benchmarking framework that measures startup latency, execution overhead, memory utilization, and resource efficiency across multiple runtime approaches, providing empirical foundations for embedded WebAssembly deployment decisions.
\end{enumerate}

\subsection{Thesis Organization}
\label{subsec:thesis-organization}

This thesis is structured to progressively address the research questions through a combination of background establishment, implementation development, and empirical evaluation:

\textbf{Chapter~\ref{chap:background}} establishes the technical foundation necessary for understanding the implementation challenges. It covers WebAssembly fundamentals, WASI architecture, the evolution from Preview 1 to Preview 2, WIT interface definition and binding generation mechanisms, WebAssembly runtime ecosystem characteristics, I2C protocol specifications, and the current state of the WASI I2C standardization proposal.

\textbf{Chapter~\ref{chap:implementation}} presents the complete development of the Preview 1 I2C ecosystem, detailing the manual bindings library design, WAMR host integration approaches, and the comparative Preview 2 implementation. This chapter directly addresses \textbf{\autoref{rq1}} by demonstrating how Preview 2 interface semantics can be effectively adapted for Preview 1 environments, and contributes to \textbf{\autoref{rq2}} by examining the implementation complexity and developer experience trade-offs between manual and automatic binding approaches.

\textbf{Chapter~\ref{chap:eval}} details the experimental methodology and presents comprehensive performance evaluation results. Through controlled hardware experiments using Raspberry Pi and Arduino platforms, this chapter provides a statistical analysis of timing characteristics, memory utilization patterns, and resource efficiency comparisons. The empirical findings directly address \textbf{\autoref{rq3}} by quantifying the performance implications of different WebAssembly runtime approaches for embedded I2C applications.

\textbf{Chapter~\ref{chap:conclusion}} synthesizes the experimental findings and implementation insights to provide definitive answers to all research questions. It examines the broader implications for embedded WebAssembly deployment, discusses the limitations of the current approach, and outlines the impact on WASI I2C standardization efforts.

\textbf{Chapter~\ref{chap:future-work}} identifies promising research directions that extend this work toward production-ready deployment scenarios.

\textbf{Chapter~\ref{chap:ethics}} briefly examines the ethical considerations surrounding WebAssembly for I2C standardization and its potential impact on technology accessibility and environmental sustainability.

This investigation provides practical guidance for embedded system developers considering WebAssembly adoption while directly supporting the WASI I2C standardization effort through the demonstration of embedded system compatibility. The findings inform ongoing standardization discussions regarding the balance between sophisticated developer experiences and resource-constrained deployment requirements, ultimately contributing to the advancement of WebAssembly in embedded computing environments.